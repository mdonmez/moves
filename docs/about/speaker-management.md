# Speaker Management

The `SpeakerManager` is the primary orchestrator for all operations related to speaker profiles. In `moves`, a "Speaker" is the central entity that associates a presentation, a transcript, and the resulting AI-generated data. This manager provides a complete set of functionalities for the lifecycle of these profiles, from creation to deletion.

## Speaker Profile and Data Storage

Each speaker profile is stored in a dedicated subdirectory within `~/.moves/speakers/`. The subdirectory is named using a unique `speaker_id` generated by the `id_generator` utility. This ensures a clean, isolated environment for each speaker's data.

The contents of a speaker's directory include:

- `speaker.json`: A metadata file containing the speaker's name, unique ID, and the absolute paths to their original, user-provided source files.
- `presentation.pdf` / `transcript.pdf`: Local copies of the source files, used during processing.
- `sections.json`: The final output of the data preparation pipeline. The existence of this file signifies that the speaker is "Ready" for a presentation session.

## Core Operations and Workflow

The `SpeakerManager`'s methods map directly to the `moves speaker` CLI commands, providing a structured workflow for the user.

1.  **Creation (`add`):** Creates a new speaker profile. It generates a unique ID, creates the necessary directory structure, and serializes the speaker's metadata into `speaker.json`.

2.  **Modification (`edit`):** Allows users to update the file paths for a speaker's source presentation or transcript. This operation modifies the `speaker.json` file without requiring the user to delete and re-add the profile.

3.  **Processing (`process`):** This is the most complex operation, responsible for running the data preparation pipeline.

    - **Asynchronous Execution:** The `process` method is designed to be asynchronous using Python's `asyncio` library. This allows for the concurrent processing of multiple speakers when invoked with a list of speakers or the `--all` flag, significantly improving performance by leveraging multiple threads for CPU-bound tasks.
    - **File Handling:** It first intelligently determines the correct files to use. If the `source_presentation` and `source_transcript` paths in `speaker.json` are valid and exist, it copies these files into the local speaker directory, overwriting any previous versions. If the source paths are invalid but local copies exist, it uses the local copies. This ensures that processing can be re-run easily after source files are updated.
    - **Pipeline Invocation:** It invokes `section_producer.generate_sections` within a separate thread using `asyncio.to_thread`. This prevents the CPU-intensive LLM call and text processing from blocking the main asyncio event loop, which is especially important when processing multiple speakers.
    - **Result Handling:** Upon completion, it saves the generated data to `sections.json` and returns a `ProcessResult` object to the CLI for user feedback.

4.  **Resolution and Deletion:**
    - **`resolve`:** A crucial internal method that finds a speaker profile based on a user-provided string, which can be either a name or a unique ID. It handles cases of ambiguity where multiple speakers might share the same name, prompting the user for a more specific identifier.
    - **`delete`:** Irreversibly removes a speaker's entire data directory and all its contents.
