# Data Models

Moves uses a comprehensive set of data models that define the structure and relationships of all system entities. These models provide type safety, validation, and clear interfaces between different system components.

## Table of Contents

- [Overview](#overview)
- [Core Data Models](#core-data-models)
- [Type Aliases](#type-aliases)
- [Model Relationships](#model-relationships)
- [Serialization Support](#serialization-support)
- [Usage Examples](#usage-examples)

## Overview

**Location**: `src/data/models.py`

The data models module defines all core data structures using Python dataclasses, providing immutability where appropriate, type safety, and clear documentation of system entities. These models serve as the foundation for data flow throughout the application.

```python
from dataclasses import dataclass
from typing import Literal
from pathlib import Path

# Type aliases for clarity and consistency
SpeakerId = str
HistoryId = str
```

## Core Data Models

### Section Model

```python
@dataclass(frozen=True)
class Section:
    content: str
    section_index: int
```

**Purpose**: Represents a single presentation slide with its aligned speech content.

**Fields**:

- **content**: The speech content that corresponds to this slide (generated by AI)
- **section_index**: Zero-based index indicating slide position in presentation

**Characteristics**:

- **Immutable**: `frozen=True` prevents modification after creation
- **Navigation Unit**: Primary unit for presentation navigation
- **AI Generated**: Content created by LLM processing

**Example**:

```python
section = Section(
    content="Welcome to our presentation on machine learning and its applications in modern technology.",
    section_index=0
)
```

### Chunk Model

```python
@dataclass(frozen=True)
class Chunk:
    partial_content: str
    source_sections: list[Section]
```

**Purpose**: Represents a sliding window of text for real-time speech matching.

**Fields**:

- **partial_content**: Normalized text content (typically 12 words)
- **source_sections**: List of contributing sections (sorted by index)

**Characteristics**:

- **Immutable**: Prevents accidental modification during navigation
- **Cross-Section**: Can span multiple presentation sections
- **Normalized**: Content processed for consistent matching

**Example**:

```python
chunk = Chunk(
    partial_content="machine learning algorithms today we will explore deep neural networks",
    source_sections=[section1, section2]  # Spans two sections
)
```

### Speaker Model

```python
@dataclass
class Speaker:
    name: str
    speaker_id: SpeakerId
    source_presentation: Path
    source_transcript: Path
```

**Purpose**: Represents a speaker profile with associated presentation materials.

**Fields**:

- **name**: Human-readable speaker name
- **speaker_id**: Unique identifier (generated from name + random suffix)
- **source_presentation**: Path to original presentation PDF
- **source_transcript**: Path to original transcript PDF

**Characteristics**:

- **Mutable**: Allows editing of presentation and transcript paths
- **File Management**: Tracks both source and local file locations
- **Unique Identity**: Each speaker has globally unique ID

**Example**:

```python
speaker = Speaker(
    name="Dr. Sarah Johnson",
    speaker_id="dr-sarah-johnson-Ax9K2",
    source_presentation=Path("/path/to/presentation.pdf"),
    source_transcript=Path("/path/to/transcript.pdf")
)
```

### SimilarityResult Model

```python
@dataclass(frozen=True)
class SimilarityResult:
    chunk: Chunk
    score: float
```

**Purpose**: Represents the result of similarity calculation between speech and content.

**Fields**:

- **chunk**: The candidate chunk that was compared
- **score**: Similarity score (0.0-1.0, higher is better)

**Characteristics**:

- **Immutable**: Prevents tampering with results
- **Sortable**: Typically sorted by score for ranking
- **Navigation Decision**: Used to determine slide transitions

**Example**:

```python
result = SimilarityResult(
    chunk=candidate_chunk,
    score=0.85  # High similarity
)
```

### Settings Model

```python
@dataclass
class Settings:
    model: str
    key: str
```

**Purpose**: Represents system configuration settings.

**Fields**:

- **model**: LLM model identifier (e.g., "gemini/gemini-2.0-flash")
- **key**: API key for LLM provider

**Characteristics**:

- **Mutable**: Allows runtime configuration changes
- **Template-Based**: Initialized from settings template
- **Validation**: Validated against available models and key formats

**Example**:

```python
settings = Settings(
    model="gemini/gemini-2.0-flash",
    key="your-api-key-here"
)
```

### ProcessResult Model

```python
@dataclass(frozen=True)
class ProcessResult:
    section_count: int
    transcript_from: Literal["SOURCE", "LOCAL"]
    presentation_from: Literal["SOURCE", "LOCAL"]
```

**Purpose**: Represents the outcome of speaker processing operation.

**Fields**:

- **section_count**: Number of sections generated from processing
- **transcript_from**: Source of transcript file used
- **presentation_from**: Source of presentation file used

**Characteristics**:

- **Immutable**: Results cannot be modified after processing
- **File Tracking**: Records which files were used for processing
- **Metrics**: Provides quantitative processing outcomes

**Example**:

```python
result = ProcessResult(
    section_count=25,
    transcript_from="SOURCE",
    presentation_from="LOCAL"
)
```

## Type Aliases

### Speaker and History Identifiers

```python
SpeakerId = str  # e.g., "john-doe-Ax9K2"
HistoryId = str  # e.g., "20240120_14-30-25"
```

**Purpose**: Provide semantic meaning to string identifiers and enable type checking.

**Benefits**:

- **Type Safety**: Prevent mixing different types of IDs
- **Code Clarity**: Make function signatures more descriptive
- **IDE Support**: Better autocomplete and error detection
- **Future Extensions**: Easy to add validation or change underlying types

**Usage Examples**:

```python
def resolve_speaker(speaker_id: SpeakerId) -> Speaker: ...
def create_history_entry(history_id: HistoryId) -> None: ...
```

## Model Relationships

### Hierarchical Structure

```
Speaker
├── Has presentation PDF
├── Has transcript PDF
├── Generates → Sections (via AI processing)
└── Creates → Chunks (from Sections)

Section
├── Has content (aligned speech)
├── Has index (slide position)
└── Contributes to → Chunks (via sliding window)

Chunk
├── Has partial_content (normalized text)
├── References → source_sections
└── Used in → SimilarityResults

SimilarityResult
├── References → Chunk
├── Has score (similarity measure)
└── Used for → Navigation decisions
```

### Data Flow Relationships

```python
# Processing flow
Speaker → PDF files → AI processing → Sections → Chunks → SimilarityResults → Navigation

# Example flow
speaker = Speaker(...)
sections = generate_sections(speaker.source_presentation, speaker.source_transcript)
chunks = generate_chunks(sections)
results = similarity_calculator.compare(speech, chunks)
best_match = results[0]  # Highest scoring result
```

### Reference Integrity

- **Sections**: Self-contained, no external references
- **Chunks**: Reference sections that created them
- **SimilarityResults**: Reference chunks they evaluated
- **Speakers**: Reference file paths (may become invalid)

## Serialization Support

### JSON Serialization

Most models support JSON serialization for persistence:

```python
# Section serialization
section_dict = {
    "content": section.content,
    "section_index": section.section_index
}

# Speaker serialization (with Path conversion)
speaker_dict = {
    "name": speaker.name,
    "speaker_id": speaker.speaker_id,
    "source_presentation": str(speaker.source_presentation),  # Path → string
    "source_transcript": str(speaker.source_transcript)
}
```

### Serialization Helpers

```python
# In section_producer.py
def convert_to_list(section_objects: list[Section]) -> list[dict[str, str | int]]:
    return [
        {"content": s.content, "section_index": s.section_index}
        for s in section_objects
    ]

def convert_to_objects(section_list: list[dict[str, str | int]]) -> list[Section]:
    return [
        Section(
            content=cast(str, s_dict["content"]),
            section_index=cast(int, s_dict["section_index"]),
        )
        for s_dict in section_list
    ]
```

### File Format Examples

**Speaker JSON** (`~/.moves/speakers/{id}/speaker.json`):

```json
{
  "name": "Dr. Sarah Johnson",
  "speaker_id": "dr-sarah-johnson-Ax9K2",
  "source_presentation": "/Users/sarah/presentations/ml-intro.pdf",
  "source_transcript": "/Users/sarah/transcripts/ml-speech.pdf"
}
```

**Sections JSON** (`~/.moves/speakers/{id}/sections.json`):

```json
[
  {
    "content": "Welcome to our comprehensive presentation on machine learning fundamentals.",
    "section_index": 0
  },
  {
    "content": "Today we'll explore neural networks, deep learning, and practical applications.",
    "section_index": 1
  }
]
```

## Usage Examples

### Creating and Using Models

```python
from src.data.models import Section, Chunk, Speaker, SimilarityResult
from pathlib import Path

# Create a presentation section
section = Section(
    content="Machine learning is transforming how we approach data analysis",
    section_index=0
)

# Create a speaker profile
speaker = Speaker(
    name="Prof. Data Science",
    speaker_id="prof-data-science-Xy5Z8",
    source_presentation=Path("./ml-presentation.pdf"),
    source_transcript=Path("./ml-transcript.pdf")
)

# Create chunks for navigation
chunk = Chunk(
    partial_content="machine learning transforming data analysis techniques",
    source_sections=[section]
)

# Similarity results for navigation decisions
result = SimilarityResult(chunk=chunk, score=0.92)
```

### Model Validation and Type Safety

```python
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    # Type checking benefits
    def process_speaker(speaker_id: SpeakerId) -> list[Section]:
        # IDE knows speaker_id is meant to be a speaker identifier
        pass

    def navigate_to_section(section_index: int) -> None:
        # Clear parameter types
        pass
```

### Working with Immutable Models

```python
# Sections and Chunks are immutable
section = Section(content="Original content", section_index=0)

# This would raise an error:
# section.content = "Modified content"  # FrozenInstanceError

# Instead, create new instances
updated_section = Section(
    content="Updated content",
    section_index=section.section_index
)
```

### Model Comparison and Sorting

```python
# Sections can be sorted by index
sections = [section2, section0, section1]
sorted_sections = sorted(sections, key=lambda s: s.section_index)

# Similarity results are typically sorted by score
results = [
    SimilarityResult(chunk1, 0.75),
    SimilarityResult(chunk2, 0.90),
    SimilarityResult(chunk3, 0.65)
]
best_results = sorted(results, key=lambda r: r.score, reverse=True)
```

### Integration with Business Logic

```python
def find_target_section(similarity_results: list[SimilarityResult]) -> Section | None:
    """Find target section from similarity results"""
    if not similarity_results:
        return None

    best_result = similarity_results[0]  # Highest scored result
    best_chunk = best_result.chunk

    # Navigate to the last section in the chunk (typical behavior)
    target_section = best_chunk.source_sections[-1]
    return target_section

def calculate_navigation_distance(current: Section, target: Section) -> int:
    """Calculate slides to navigate"""
    return target.section_index - current.section_index
```

### Error Handling with Models

```python
def safe_section_creation(content: str, index: int) -> Section | None:
    """Safely create section with validation"""
    try:
        if not content.strip():
            raise ValueError("Section content cannot be empty")
        if index < 0:
            raise ValueError("Section index must be non-negative")

        return Section(content=content, section_index=index)
    except ValueError as e:
        print(f"Invalid section data: {e}")
        return None

# Usage
section = safe_section_creation("Valid content", 0)
if section:
    print(f"Created section {section.section_index}")
```

The data models provide a solid foundation for type-safe, reliable data handling throughout the Moves system. Their clear structure and immutability characteristics help prevent bugs while maintaining code clarity and maintainability.
